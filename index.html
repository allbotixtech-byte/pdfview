<!DOCTYPE html>
<html>
<head>
  <title>Temi PDF Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes">
  
  <!-- PDF.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    body {
      font-family: Arial, sans-serif;
      background: #000;
      color: white;
      overflow: hidden;
      position: fixed;
      height: 100vh;
      width: 100vw;
    }

    #openBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 25px 60px;
      font-size: 26px;
      background: #00c853;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      z-index: 10;
    }

    #closeBtn {
      position: fixed;
      top: 20px;
      right: 30px;
      padding: 14px 28px;
      font-size: 20px;
      background: rgba(255, 0, 0, 0.9);
      color: white;
      border: none;
      border-radius: 10px;
      z-index: 1001;
      cursor: pointer;
      display: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    #pdfViewer {
      width: 100vw;
      height: 100vh;
      display: none;
      background: #333;
      overflow: auto;
      position: fixed;
      top: 0;
      left: 0;
      -webkit-overflow-scrolling: touch;
    }

    #pdfCanvas {
      display: block;
      background: white;
      cursor: grab;
      touch-action: none;
      margin: 0 auto;
    }

    #pdfCanvas:active {
      cursor: grabbing;
    }

    .pageInfo {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 16px;
      z-index: 1000;
      display: none;
    }

    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 20px;
      display: none;
      z-index: 1002;
    }
  </style>
</head>
<body>

  <button id="openBtn" onclick="openLocalPDF()">üìÑ Open Bharat Deck</button>
  <button id="closeBtn" onclick="closePDF()">‚ùå Close</button>
  
  <div id="pdfViewer">
    <canvas id="pdfCanvas"></canvas>
  </div>
  
  <div class="loading" id="loading">Loading PDF...</div>
  <div class="pageInfo" id="pageInfo">Page: 1 / 1</div>

  <script>
    let pdfDoc = null;
    let pageNum = 1;
    let pageRendering = false;
    let pageNumPending = null;
    let scale = 1;
    let isDragging = false;
    let startX, startY, scrollLeft, scrollTop;
    let touchStartDistance = null;
    let touchStartScale = 1;
    let maxScale = 5;
    let minScale = 0.5;
    let renderTimeout = null;
    let currentPage = null;
    let lastTouchTime = 0;
    let lastTouchScale = 1;

    // DOM elements
    const pdfViewer = document.getElementById('pdfViewer');
    const pdfCanvas = document.getElementById('pdfCanvas');
    const ctx = pdfCanvas.getContext('2d');
    const loading = document.getElementById('loading');
    const pageInfo = document.getElementById('pageInfo');

    function openLocalPDF() {
      document.getElementById('openBtn').style.display = 'none';
      pdfViewer.style.display = 'block';
      document.getElementById('closeBtn').style.display = 'block';
      loading.style.display = 'block';
      pageInfo.style.display = 'block';

      // Load local PDF file
      const pdfUrl = 'BHARAT_DECK-v2.pdf'; // Your local PDF file name
      
      // Load PDF using PDF.js
      pdfjsLib.getDocument(pdfUrl).promise.then(function(pdfDoc_) {
        pdfDoc = pdfDoc_;
        pageInfo.textContent = `Page: 1 / ${pdfDoc.numPages}`;
        loading.style.display = 'none';
        
        // Initial render with full screen
        renderPage(pageNum);
      }).catch(function(error) {
        console.error('Error loading PDF:', error);
        loading.textContent = 'Error loading PDF. Please make sure BHARAT_DECK-v2.pdf is in the same folder.';
        setTimeout(() => {
          closePDF();
        }, 3000);
      });
    }

    function calculateOptimalScale(page) {
      const viewport = page.getViewport({ scale: 1 });
      const containerWidth = window.innerWidth;
      const containerHeight = window.innerHeight;
      
      // Calculate scale to fit width or height
      const scaleX = containerWidth / viewport.width;
      const scaleY = containerHeight / viewport.height;
      
      // Use the smaller scale to fit entire page on screen
      return Math.min(scaleX, scaleY) * 0.95; // 95% to add a small margin
    }

    function renderPage(num, immediate = false) {
      if (renderTimeout && !immediate) {
        clearTimeout(renderTimeout);
      }
      
      const renderFunction = function() {
        pageRendering = true;
        
        pdfDoc.getPage(num).then(function(page) {
          currentPage = page;
          
          // Calculate optimal scale for full screen on first load
          if (scale === 1) {
            scale = calculateOptimalScale(page);
          }
          
          const viewport = page.getViewport({ scale: scale });
          
          // Set canvas dimensions to match the viewport
          pdfCanvas.width = viewport.width;
          pdfCanvas.height = viewport.height;
          
          // Clear canvas
          ctx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);
          
          // Reset canvas transform to prevent rotation
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          
          // Render PDF page
          const renderContext = {
            canvasContext: ctx,
            viewport: viewport
          };
          
          return page.render(renderContext).promise;
        }).then(function() {
          pageRendering = false;
          if (pageNumPending !== null) {
            renderPage(pageNumPending, true);
            pageNumPending = null;
          }
        });
        
        pageInfo.textContent = `Page: ${num} / ${pdfDoc.numPages}`;
      };
      
      if (immediate) {
        renderFunction();
      } else {
        renderTimeout = setTimeout(renderFunction, 16);
      }
    }

    function queueRenderPage(num) {
      if (pageRendering) {
        pageNumPending = num;
      } else {
        renderPage(num, true);
      }
    }

    // Simple pinch zoom with scale clamping
    let initialTouches = [];
    
    pdfCanvas.addEventListener('touchstart', function(e) {
      e.preventDefault();
      
      if (e.touches.length === 2) {
        // Store initial touch positions
        initialTouches = [
          { x: e.touches[0].clientX, y: e.touches[0].clientY },
          { x: e.touches[1].clientX, y: e.touches[1].clientY }
        ];
        touchStartScale = scale;
        lastTouchScale = scale;
      } else if (e.touches.length === 1) {
        // Drag start
        isDragging = true;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        scrollLeft = pdfViewer.scrollLeft;
        scrollTop = pdfViewer.scrollTop;
        pdfCanvas.style.cursor = 'grabbing';
      }
    }, { passive: false });

    pdfCanvas.addEventListener('touchmove', function(e) {
      e.preventDefault();
      
      if (e.touches.length === 2 && initialTouches.length === 2) {
        // Calculate current distance
        const currentTouches = [
          { x: e.touches[0].clientX, y: e.touches[0].clientY },
          { x: e.touches[1].clientX, y: e.touches[1].clientY }
        ];
        
        // Calculate initial and current distances
        const initialDistance = Math.sqrt(
          Math.pow(initialTouches[1].x - initialTouches[0].x, 2) +
          Math.pow(initialTouches[1].y - initialTouches[0].y, 2)
        );
        
        const currentDistance = Math.sqrt(
          Math.pow(currentTouches[1].x - currentTouches[0].x, 2) +
          Math.pow(currentTouches[1].y - currentTouches[0].y, 2)
        );
        
        // Avoid division by zero and handle small distances
        if (initialDistance > 10) {
          const scaleChange = currentDistance / initialDistance;
          const newScale = Math.max(minScale, Math.min(maxScale, touchStartScale * scaleChange));
          
          // Only update if scale actually changed
          if (Math.abs(newScale - scale) > 0.01) {
            scale = newScale;
            
            // Debounce rendering
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(() => {
              renderPage(pageNum, true);
            }, 16); // Render at ~60fps
          }
        }
      } else if (isDragging && e.touches.length === 1) {
        // Drag
        const x = e.touches[0].clientX;
        const y = e.touches[0].clientY;
        const walkX = (x - startX) * 2;
        const walkY = (y - startY) * 2;
        pdfViewer.scrollLeft = scrollLeft - walkX;
        pdfViewer.scrollTop = scrollTop - walkY;
      }
    }, { passive: false });

    pdfCanvas.addEventListener('touchend', function(e) {
      e.preventDefault();
      isDragging = false;
      initialTouches = [];
      pdfCanvas.style.cursor = 'grab';
      
      // Final render after touch ends
      if (renderTimeout) clearTimeout(renderTimeout);
      renderPage(pageNum, true);
    }, { passive: false });

    // Prevent default browser touch behaviors
    document.addEventListener('touchmove', function(e) {
      if (pdfViewer.style.display === 'block' && e.touches.length === 2) {
        e.preventDefault();
      }
    }, { passive: false });

    // Mouse wheel zoom for desktop testing
    pdfCanvas.addEventListener('wheel', function(e) {
      e.preventDefault();
      if (e.ctrlKey) {
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        scale = Math.max(minScale, Math.min(maxScale, scale * delta));
        renderPage(pageNum, true);
      } else {
        pdfViewer.scrollTop += e.deltaY;
        pdfViewer.scrollLeft += e.deltaX;
      }
    });

    // Double tap to fit screen
    let lastTap = 0;
    pdfCanvas.addEventListener('touchend', function(e) {
      const currentTime = new Date().getTime();
      const tapLength = currentTime - lastTap;
      
      if (tapLength < 300 && tapLength > 0) {
        // Double tap detected - fit to screen
        if (currentPage) {
          scale = calculateOptimalScale(currentPage);
        }
        renderPage(pageNum, true);
        e.preventDefault();
      }
      lastTap = currentTime;
    });

    // Swipe for page navigation
    let touchStartX = 0;
    let touchStartY = 0;
    
    pdfViewer.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
    });

    pdfViewer.addEventListener('touchend', function(e) {
      if (!touchStartX || e.touches.length > 0) return;
      
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const diffX = touchStartX - touchEndX;
      const diffY = touchStartY - touchEndY;
      
      // Check if it's mostly horizontal swipe
      if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 100) {
        if (diffX > 0 && pageNum < pdfDoc.numPages) {
          pageNum++;
          if (currentPage) {
            scale = calculateOptimalScale(currentPage);
          }
        } else if (diffX < 0 && pageNum > 1) {
          pageNum--;
          if (currentPage) {
            scale = calculateOptimalScale(currentPage);
          }
        }
        queueRenderPage(pageNum);
      }
      
      touchStartX = 0;
      touchStartY = 0;
    });

    function closePDF() {
      pdfViewer.style.display = 'none';
      document.getElementById('closeBtn').style.display = 'none';
      document.getElementById('openBtn').style.display = 'block';
      loading.style.display = 'none';
      pageInfo.style.display = 'none';
      
      // Reset state
      pdfDoc = null;
      pageNum = 1;
      scale = 1;
      currentPage = null;
      initialTouches = [];
      
      if (renderTimeout) {
        clearTimeout(renderTimeout);
        renderTimeout = null;
      }
    }

    // Handle orientation change
    window.addEventListener('orientationchange', function() {
      setTimeout(() => {
        if (pdfDoc && currentPage) {
          scale = calculateOptimalScale(currentPage);
          renderPage(pageNum, true);
        }
      }, 300);
    });

    // Auto-fit on window resize
    window.addEventListener('resize', function() {
      if (pdfDoc && currentPage) {
        scale = calculateOptimalScale(currentPage);
        renderPage(pageNum, true);
      }
    });
  </script>

</body>
</html>
